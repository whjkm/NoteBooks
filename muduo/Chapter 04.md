- [Chapter 04](#chapter-04)
  - [线程安全性](#线程安全性)
  - [线程的创建与销毁](#线程的创建与销毁)
    - [线程创建](#线程创建)
    - [线程销毁](#线程销毁)
  - [多线程与IO](#多线程与io)
  - [用RAII包装文件描述符](#用raii包装文件描述符)
  - [多线程与fork()](#多线程与fork)
  - [多线程与Signal](#多线程与signal)

# Chapter 04

多线程程序的正确性不能依赖于任何一个线程的执行速度，不能通过原地等待（`sleep()`）来假定其他线程的事件已经发生，而必须通过适当的同步来让当前线程能看到其他线程的事件的结果。

## 线程安全性

编写线程安全程序的一个难点在于线程安全是不可组合的（composable），一个函数`foo()`调用了两个线程安全的函数，而这个`foo()`函数本身很可能不是线程安全的。

- 尽量把`class`设计成`immutable`的。
- 凡是非共享的对象都是彼此独立的，如果一个对象从始至终只被一个线程用到，那么它就是线程安全的。
- 共享对象的`read-only`操作是安全的。
- `C++`标准库中的绝大多数泛型算法是线程安全的，因为这些都是无状态纯函数。只要输入区间是线程安全的，那么泛型函数就是线程安全的。

## 线程的创建与销毁

### 线程创建

- 程序库不应该在未告知的情况下创建自己的“背景线程”。
- 尽量用相同的方式创建线程。
- 在进入`main()`函数之前不应该启动线程。因为这会影响全局对象的安全构造。
- 程序中线程的创建最好在初始化阶段全部完成。在程序运行期间不再创建或销毁线程。

### 线程销毁

- 自然死亡：从线程主函数返回，线程正常退出。
- 非正常死亡：从线程主函数抛出异常或线程触发`segfault`信号等非法操作。通常伴随着进程死亡。
- 自杀：在线程中调用`pthread_exit()`来立即退出线程。
- 他杀：其他线程调用`pthread_cancel()`来强制终止某个线程。

线程正常退出的方式只有一种，即自然死亡。任何从外部强行终止线程的做法和想法都是错误的。

[请不要做线程的异步撤消的设计](http://www.cppblog.com/lymons/archive/2008/12/19/69810.html)

[尽可能避免线程的延迟撤销处理](http://www.cppblog.com/lymons/archive/2008/12/25/70227.html)

`exit(3)`函数在C++中的作用除了终止进程，还会析构全局对象和已经构造完的函数静态对象。这有潜在的死锁可能。


## 多线程与IO

***“显然是正确”*** 方式：一个文件只能由一个进程中的一个线程来读写。

多线程应该遵循的原则：
- 每个文件描述符只由一个线程操作，从而轻松解决消息收发的顺序性问题，也避免关闭文件描述符的各种`race condition`。
- 一个线程可以操作多个文件描述符，但一个线程不能操作别的线程拥有的文件描述符。

**Exception**:

- 对于磁盘文件，在必要的时候多个线程可以同时调用`pread(2)/pwrite(2)`来读写同一个文件；
- 对于`UDP`, 由于协议本身保证消息的原子性，在适当的条件下（比如消息之间彼此独立）可以多个线程同时读写同一个`UDP`文件描述符。


## 用RAII包装文件描述符

用`socket`对象包装文件描述符，所有对此文件描述符的读写操作都通过此对象进行，在对象的析构函数里关闭文件描述符。

用对象包装资源，把资源管理与对象生命期管理统一起来（`RAII`）。

## 多线程与fork()

`fork()` 一般不能在多线程程序中调用。

[准则3：多线程程序里不准使用fork](http://www.cppblog.com/lymons/archive/2008/06/01/51836.html)

**Solution**:

- 做`fork()`的时候，在它之前让其他的线程完全终止。
- `fork()`之后，在子进程中马上调用`exec()`,彻底隔断子进程和父进程的联系。
- 其他线程中，不做`fork-unsafe`的处理。

## 多线程与Signal

在多线程程序中，使用`signal`的第一原则是**不要使用`signal`**。

Reference:

[UNIX上的C++程序设计守则(1)](http://www.cppblog.com/lymons/archive/2008/06/01/51838.html)

[UNIX上C++程序设计守则 (2)](http://www.cppblog.com/lymons/archive/2008/06/01/51837.html)

